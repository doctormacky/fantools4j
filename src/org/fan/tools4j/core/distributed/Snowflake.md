# 雪花算法（分布式ID生成器）

## 起源
Snowflake中文含义为雪花，世界上有没有两片完全相同的雪花；

意指该算法像雪花一样，在分布式环境下每次都生成独一无二的ID；

## 特点
在分布式环境下，我们希望一个ID生成器可以具备以下几个特点：

* 全局唯一性：不能出现有重复的ID。
* 递增性：确保生成ID对于用户或业务是递增的（对存储友好）。
* 高可用性：确保任何时候都能生成正确的ID。
* 高性能性：在高并发的环境下依然表现良好。

## 方案

### UUID
Java自带算法，根据以太网卡地址、纳秒级时间、芯片ID码等生成的一串唯一随机36位字符串（32个字符串+4个“-”）。它可以保证唯一性，且据说够用N亿年，但是其业务可读性差，无法有序递增。

### Snowflake
雪花算法，由64位整数组成分布式ID，性能较高，并且在单机上递增。最早由twitter在2014年开源，源码见：https://github.com/twitter-archive/snowflake/tags

### UidGenerator
UidGenerator是百度开源的分布式ID生成器，其基于雪花算法实现。具体参考：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md

### Leaf
Leaf是美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但需要依赖关系数据库、Zookeeper等中间件。具体参考：https://tech.meituan.com/MT_Leaf.html

## 原理
| 符号位(1) |                  时间戳(41)                   | 机器码(10) |  序列号(12)   |
|-----------|-----------------------------------------------|------------|---------------|
|         0 | 0000000000 0000000000 0000000000 0000000000 0 | 0000000000 | 0000000000 00 |

雪花算法原理非常简单，它每次产生的是一个long型64位的值，第一位是符号位未使用（正负）。

接下来是41位的毫秒单位的时间戳，我们可以计算下：`2^41/1000*60*60*24*365 ≈ 69` 年。
也就是这个时间戳相对于起始值（不是1970年）可以使用69年不重复，这个对于大部分系统够用了。

紧跟着是10位的机器位，最多可以支持 `2^10 = 1024` 台机器。

最后是12位的递增序列号，表示每毫秒最多可产生 `2^12 = 4096` 个序列，也就是说 `QPS = 4096*1000 ≈ 410W`，这个并发量应该来说足够了 。

## 实现
雪花算法因为原理简单清晰，实现起来也很简单。

主要方法就是确定各个位长度，然后计算完之后左移到相应的位置，拼在一起就是一个long型的64位ID了。
```
return (timeOffset << timestampLeftShift) // 时间位
     | (datacenterId << datacenterIdShift) // 机器位1
     | (workerId << workerIdShift) // 机器位2
     | sequence;	// 序列位
```

注意几个地方：
1. **位数调整**：为了保证系统的稳定性，时间位最好不要动（最多69年），其余位可自行调整长度，也就是说 `机器位+序列位 <= 64-1-41=22` 位；
2. **系统时钟回退**：如果运行过程中发生系统时钟回退，回退时间少可pack这段时间后再生成，回退时间长直接不可用；
3. **序列号溢出**：如果QPS超过了最大值，序列号不够，则while循环等待直到下一毫秒重新生成序列；

## 机器ID
雪花算法应用场景是分布式场景，需要传入机器ID，必须保证每个实例传入的机器ID不重复（datacenter可传0）。

一般来说有以下几个办法：
1. **自动部署**：对于已经实现自动部署的系统来说，只需要在自动部署时分配好机器ID，然后传入即可；
2. **中间件-Redis/Zookeeper**：调用redis.incr取唯一值，然后对1024取模即可（Zk同理）；
3. **机器-Ip/Mac**：将IP地址中的每个字节的Ascii码值相加，然后对1024取模即可（Mac同理），此方法**可能重复**；
```
    private static long makeWorkerId() {
        try {
            String hostAddress = Inet4Address.getLocalHost().getHostAddress();
            int[] ips = StringUtils.toCodePoints(hostAddress);
            int sums = 0;
            for (int ip: ips) {
                sums += ip;
            }
            return (sums % 1024);
        } catch (UnknownHostException e) {
            return RandomUtils.nextLong(0, 1024);
        }
    }
```

## 变种

### 支持秒（TimeUnit）
雪花算法时间位默认是毫秒，这样生成的ID值QPS可达410W，大多数情况下，我们不需要这么大的QPS。

我们引入单位秒，这样只需要31位的时间位，也就是 `2^31/60*60*24*365 ≈ 68` 年。

通过换成秒，减少时间位，调整机器位和序列位，我们可以生成更小的ID值，支持更多的业务场景。

### 日期前缀（nextSn）

雪花算法生成的ID值是一个无含义的值，在日常业务中，经常需要在生成的序号上加上日期前缀，方便业务查询。

我们将时间位做个简单处理，由于有时间前缀`yyyyMMdd`，时间位只需要保留当日的偏移值即可，也就是说毫秒值对`60*60*24*1000`取模即可。

通过以上处理，我们可以得到一个带时间前缀的序列值，由于这个序列值长度变长，可能超过64位，所以返回类型改为String。
