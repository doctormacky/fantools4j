# 雪花算法（分布式ID生成器）

## 起源
Snowflake中文含义为雪花，世界上有没有两片完全相同的雪花；

意指该算法像雪花一样，在分布式环境下每次都生成独一无二的ID；

## 特点
在分布式环境下，我们希望一个ID生成器可以具备以下几个特点：

* 全局唯一性：不能出现有重复的ID。
* 递增性：确保生成ID对于用户或业务是递增的（对存储友好）。
* 高可用性：确保任何时候都能生成正确的ID。
* 高性能性：在高并发的环境下依然表现良好。

## 方案

### UUID
Java自带算法，根据以太网卡地址、纳秒级时间、芯片ID码等生成的一串唯一随机36位字符串（32个字符串+4个“-”）。它可以保证唯一性，且据说够用N亿年，但是其业务可读性差，无法有序递增。

### Snowflake
雪花算法，由64位整数组成分布式ID，性能较高，并且在单机上递增。最早由twitter在2014年开源，源码见：https://github.com/twitter-archive/snowflake/tags

### UidGenerator
UidGenerator是百度开源的分布式ID生成器，其基于雪花算法实现。具体参考：https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md

### Leaf
Leaf是美团开源的分布式ID生成器，能保证全局唯一，趋势递增，但需要依赖关系数据库、Zookeeper等中间件。具体参考：https://tech.meituan.com/MT_Leaf.html

## 原理
| 符号位(1) |                  时间戳(41)                   | 机器码(10) |  序列号(12)   |
|-----------|-----------------------------------------------|------------|---------------|
|         0 | 0000000000 0000000000 0000000000 0000000000 0 | 0000000000 | 0000000000 00 |

雪花算法原理非常简单，它每次产生的是一个long型64位的值，第一位是符号位未使用（正负）。

接下来是41位的毫秒单位的时间戳，我们可以计算下：`2^41/1000*60*60*24*365 ≈ 69`
也就是这个时间戳相对于起始值（不是1970年）可以使用69年不重复，这个对于大部分系统够用了。

紧跟着是10位的机器位，最多可以支持 `2^10 = 1024` 台机器。

最后是12位的递增序列号，表示每毫秒最多可产生 `2^12 = 4096` 个序列，也就是说 `QPS = 4096*1000 ≈ 410W`，这个并发量应该来说足够了 。

## 实现
雪花算法因为原理简单清晰，实现起来也很简单。

主要方法就是确定各个位长度，然后计算完之后左移到相应的位置，拼在一起就是一个long型的64位ID了。

代码：`(timeOffset << timestampLeftShift) // 时间位
		 | (datacenterId << datacenterIdShift) // 机器位1
		 | (workerId << workerIdShift) // 机器位2
		 | sequence;	// 序列位`

注意几个地方：
1. **位数调整**：为了保证系统的稳定性，时间位最好不要动（最多69年），其余位可自行调整长度，也就是说 `机器位+序列位 <= 64-1-41=22` 位；
2. **系统时钟回退**：如果运行过程中发生系统时钟回退，回退时间少可pack这段时间后再生成，回退时间长直接不可用；
3. **序列号溢出**：如果QPS超过了最大值，序列号不够，则while循环等待直到下一毫秒重新生成序列；

## 变种

### 支持秒（TimeUnit）
雪花算法时间位默认是毫秒，这样生成的ID值QPS可达410W，大多数情况下，我们不需要这么大的QPS。

我们引入单位秒，这样只需要31位的时间位，也就是 `2^31/60*60*24*365 ≈ 68` 年。

通过换成秒，减少时间位，调整机器位和序列位，我们可以生成更小的ID值，支持更多的业务场景。

### 日期前缀（nextSn）

雪花算法生成的ID值是一个无含义的值，在日常业务中，经常需要在生成的序号上加上日期前缀，方便业务查询。

我们将时间位做个简单处理，由于有时间前缀`yyyyMMdd`，时间位只需要保留当日的偏移值即可，也就是说毫秒值对`60*60*24*1000`取余即可。

通过以上处理，我们可以得到一个带时间前缀的序列值，由于这个序列值长度变长，可能超过64位，所以返回类型改为String。
